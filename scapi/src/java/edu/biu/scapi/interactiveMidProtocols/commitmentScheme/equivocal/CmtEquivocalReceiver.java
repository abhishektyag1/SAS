/**
 * 
 */
package edu.biu.scapi.interactiveMidProtocols.commitmentScheme.equivocal;

import java.io.IOException;

import edu.biu.scapi.comm.Channel;
import edu.biu.scapi.exceptions.CheatAttemptException;
import edu.biu.scapi.exceptions.CommitValueException;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtCCommitmentMsg;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtCDecommitmentMessage;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtReceiver;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtWithProofsReceiver;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtCommitValue;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtRCommitPhaseOutput;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.pedersen.CmtPedersenWithProofsReceiver;
import edu.biu.scapi.securityLevel.EquivocalCmt;

/**
 * Concrete implementation of Equivocal commitment scheme in the receiver's point of view.Pseudo code:<p>
 * This is a protocol to obtain an equivocal commitment from any commitment with a ZK-protocol of the commitment value.Pseudo code:<p>
 * The equivocality property means that a simulator can decommit to any value it needs (needed for proofs of security).<p>
 * 
 * The pseudo code of this protocol can be found in Protocol 3.7 of pseudo codes document at {@link http://crypto.biu.ac.il/scapi/SDK_Pseudocode_SCAPI_V2.0.0.pdf}.<p>
 * 
 * 
 * @author Cryptography and Computer Security Research Group Department of Computer Science Bar-Ilan University (Moriya Farbstein)
 *
 */
public class CmtEquivocalReceiver implements CmtReceiver, EquivocalCmt {
	
	/*
	  Runs the following pseudo code:
	  	Commit phase
			RUN any COMMIT protocol for C to commit to x
		Decommit phase, using ZK protocol of decommitment value
			Run ZK protocol as the verifier, that x is the correct decommitment value
			IF verifier-output of ZK is ACC
		          OUTPUT ACC and x
		    ELSE
		          OUTPUT REJ

	 */
	
	protected CmtWithProofsReceiver receiver;
	
	/**
	 * Constructor that gets the receiver to use in the protocol execution.
	 * @param receiver
	 */
	public CmtEquivocalReceiver(CmtWithProofsReceiver receiver){
		this.receiver = receiver;
	}
	
	/**
	 * Constructor that gets channel to use in the protocol execution and chooses default receiver.
	 * @param channel
	 * @throws CheatAttemptException 
	 * @throws IOException 
	 * @throws ClassNotFoundException 
	 */
	public CmtEquivocalReceiver(Channel channel) throws ClassNotFoundException, IOException, CheatAttemptException{
		receiver = new CmtPedersenWithProofsReceiver(channel);
	}
	
	/**
	 * Runs the commit phase of the protocol:<P>
	 * "RUN any COMMIT protocol for C to commit to x".
	 */
	public CmtRCommitPhaseOutput receiveCommitment() throws ClassNotFoundException, IOException {
		//Delegate to the underlying receiver.
		return receiver.receiveCommitment();
	}

	/**
	 * Runs the decommit phase of the protocol:<P>
	 * "Run ZK protocol as the verifier, that x is the correct decommitment value<P>
	 *		IF verifier-output of ZK is ACC<P>
	 *          OUTPUT ACC and x<P>
	 *    	ELSE<P>
	 *          OUTPUT REJ". 
	 */
	public CmtCommitValue receiveDecommitment(long id) throws IOException, ClassNotFoundException, CheatAttemptException, CommitValueException {
		//During the execution of verifyCommittedValue, the x is received by the receiver.
		return receiver.verifyCommittedValue(id);
	}
	
	@Override
	public CmtCommitValue verifyDecommitment(CmtCCommitmentMsg commitmentMsg, CmtCDecommitmentMessage decommitmentMsg) {
		throw new IllegalStateException("The Decommitment phase of this scheme is interactive. Thus, it can't generate a decommitment message. Call decommit function");
	}

	@Override
	public Object[] getPreProcessedValues() {
		//Delegate to the underlying receiver.
		return receiver.getPreProcessedValues();
	}

	@Override
	public Object getCommitmentPhaseValues(long id) {
		//Delegate to the underlying receiver.
		return receiver.getCommitmentPhaseValues(id);
	}
	
	/**
	 * This function converts the given commit value to a byte array. 
	 * @param value
	 * @return the generated bytes.
	 */
	public byte[] generateBytesFromCommitValue(CmtCommitValue value){
		//Delegate to the underlying receiver.
		return receiver.generateBytesFromCommitValue(value);
	}
}